#
# Cookbook Name:: firewalldconfig
# Provider:: default
#
# Copyright:: 2015, The University of Illinois at Chicago

action :create do
  current = self.class.read_conf(new_resource.file_path)
  current ||= {
    cleanup_on_exit: true,
    default_zone:    'public',
    ipv6_rpfilter:   true,
    lockdown:        false,
    minimal_mark:    100
  } if current.nil?
  new_resource.updated_by_last_action(update_config(current, :create))
end

action :create_if_missing do
  if ::File.file? new_resaurce.file_path
    Chef::Log.debug("firewalld already configured at #{new_resource.file_path}")
    new_resource.updated_by_last_action(false)
  else
    action_create
  end
end

action :merge do
  current = self.class.read_conf(new_resource.file_path)
  if current.nil?
    action_create
  else
    new_resource.updated_by_last_action(update_config(current, :merge))
  end
end

@lib_dir = '/usr/lib/firewalld'
@etc_dir = '/etc/firewalld'
class << self
  attr_accessor :lib_dir
  attr_accessor :etc_dir
end

CONFIG_OPT = {
  'CleanupOnExit' => {
    sym: :cleanup_on_exit,
    val: ->(s) { /^(yes|true)/i.match(s) ? true : false }
  },
  'DefaultZone'   => {
    sym: :default_zone,
    val: ->(s) { s }
  },
  'IPv6_rpfilter' => {
    sym: :ipv6_rpfilter,
    val: ->(s) { /^(yes|true)/i.match(s) ? true : false }
  },
  'Lockdown'      => {
    sym: :lockdown,
    val: ->(s) { /^(yes|true)/i.match(s) ? true : false }
  },
  'MinimalMark'   => {
    sym: :minimal_mark,
    val: ->(s) { s.to_i }
  }
}

def self.read_conf(path = nil)
  path = "#{etc_dir}/firewalld.conf" if path.nil?
  return {} unless ::File.file? path
  settings = {}
  ::File.open(path).each do |line|
    next unless /^(?<key>\w+)=(?<value>.*)/ =~ line
    opt = CONFIG_OPT[key]
    next if opt.nil?
    settings[opt[:sym]] = opt[:val].call(value)
  end
  settings
end

def self.write_conf(conf, path)
  lines = read_conf_lines(path)
  set_options = substitute_conf_lines(conf, lines)
  add_conf_lines(conf, lines, CONFIG_OPT.keys - set_options)
  fh = ::File.open(path, 'w')
  lines.each do |line|
    fh.puts line
  end
  fh.close
end

def self.read_conf_lines(path)
  return ::File.open(path).readlines if ::File.file? path
  ["# Config generated by chef firewalldconf cookbook.\n"]
end

def self.substitute_conf_lines(conf, lines)
  set_opts = []
  lines.each do |line|
    CONFIG_OPT.each do |opt, info|
      set_opts << opt if line.gsub!(/^#{opt}=.*/, conf[info[:sym]].to_s)
    end
  end
  set_opts
end

def self.add_conf_lines(conf, lines, opts)
  opts.each do |opt|
    lines << "#{opt}=#{conf[CONFIG_OPT[opt][:sym]]}"
  end
end

def build_config(current)
  config = current.clone
  [:cleanup_on_exit, :default_zone, :ipv6_rpfilter, :lockdown, :minimal_mark
  ].each do |attr|
    val = new_resource.method(attr).call
    next if val.nil?
    config[attr] = val
  end
  config
end

def update_config(current, action)
  config = build_config current
  if config == current
    Chef::Log.debug(
      "#{action} #{new_resource.file_path} already as specified."
    )
    return false
  else
    converge_config(config, action)
    return true
  end
end

def converge_config(config, action)
  converge_by "#{action} firewalld conf #{new_resource.file_path}" do
    self.class.write_conf(config, new_resource.file_path)
    new_resource.updated_by_last_action(true)
  end
end
